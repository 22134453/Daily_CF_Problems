**提示 1：** 答案必须是奇数，为什么？

**提示 2：** 对于某个奇数最多能填入多少个格子？

答案不可能是偶数。为什么呢？

因为考虑中间的两行两列，不能有任何一个格子是黑色的。而这样，这样的行和列就可以替换为一行一列，也就转化为更小的答案了。

同时，一个 $n\times n$ 的方阵，在 $n$ 为奇数时，最多能填入 $(n^2+1)/2$ 个位置。

所以至少要让 $(n^2+1)/2$ 大于给定的这个数。

提醒自己一句：一定能构造吗？

发现一般而言是可以的，因为可以利用中间行和列调整。

但是输入 $3$ 时，我们不得不输出 $5$ ，所以要特判。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    mod = 998244353
    
    M = 2 * 10 ** 5
    pw2 = [1] * (M + 1)
    
    for i in range(1, M + 1):
        pw2[i] = 2 * pw2[i - 1] % mod
    
    t = II()
    outs = []
    
    rev4 = ((mod + 1) // 2 + mod) // 2
    
    for _ in range(t):
        n, q = MII()
        s = [int(c) for c in I()]
        c0 = s.count(0)
        c1 = s.count(1)
        
        for _ in range(q):
            idx = II() - 1
            
            if s[idx]:
                c1 -= 1
                c0 += 1
            else:
                c1 += 1
                c0 -= 1
            
            s[idx] ^= 1
            
            outs.append((c0 * (c0 + 1) // 2 + c1 * (c1 + 1) // 2 - c0 * c1 - 1) * pw2[n - 1] % mod * rev4 % mod)
    
    print('\n'.join(map(str, outs)))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);
 
    int t;
    cin >> t;
 
    int mod = 998244353, M = 2e5;
    vector<int> pw2(M + 1, 1);
 
    for (int i = 1; i <= M; i ++)
        pw2[i] = 1ll * pw2[i - 1] * 2 % mod;
    
    int rev4 = ((mod + 1) / 2 + mod) / 2;
 
    while (t --) {
        int n, q;
        cin >> n >> q;
 
        string s;
        cin >> s;
 
        int c0 = 0, c1 = 0;
 
        for (auto &c: s) {
            if (c == '0') c0 ++;
            else c1 ++;
        }
 
        while (q --) {
            int idx;
            cin >> idx;
            idx --;
 
            if (s[idx] == '0') {
                c0 --, c1 ++;
                s[idx] = '1';
            }
            else {
                c1 --, c0 ++;
                s[idx] = '0';
            }
 
            cout << ((1ll * c0 * (c0 + 1) / 2 % mod + 1ll * c1 * (c1 + 1) / 2 % mod - 1ll * c0 * c1 % mod - 1) % mod * pw2[n - 1] % mod * rev4 % mod + mod) % mod << '\n';
        }
    }
 
    return 0;
}
```
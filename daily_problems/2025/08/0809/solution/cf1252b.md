**提示 1：** 尝试构造一组子集，跟数值大小无关，且其和可以直接比较。

我们先将数组进行排序。不妨从大到小排序。

两个数组的大小可以直接比较，当且仅当一个是另一个的子集 / 两个集合只差了一个元素 $x$ 。

我们基于此进行构造，使得我们能构造出一个长度为 $\frac{n(n+1)}{2}$ 的元素和从小到大的一个序列。

先选择一元子集。肯定是每个元素单独成集合。

接下来，二元子集只有包含最大值时，才能比前面所有子集大。因此至少是 $a_1+a_n$ 。接下来要取二元子集，就只能继续取 $a_1+a_{n-1},\dots,a_1+a_3,a_1+a_2$ ，因为必须包含 $a_1$ 才能保证比前一个子集大，而第二个元素有 $n-1$ 种取法。

类似的，能保证比 $a_1+a_2$ 大的三元子集是 $a_1+a_2+a_n$ ，接下来选取 $a_1+a_2+\dots+a_{n-1},\dots,a_1+a_2+a_4,a_1+a_2+a_3$ ，能选出 $n-2$ 个子集。

类似地，我们对于 $k$ 元子集，选取长度为 $k-1$ 的前缀，再选取 $n-(k-1)$ 长度后缀中的每一个元素。

这样我们选取出来的子集序列的总长度为 $n+(n-1)+\dots+1=\frac{n(n+1)}{2}$ ，因此完成了满足条件的构造。

时间复杂度为 $\mathcal{nk}$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    mod = 10 ** 9 + 7
    path = [[] for _ in range(n)]
    
    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)
    
    que = [0]
    parent = [-1] * n
    
    for u in que:
        for v in path[u]:
            if parent[u] != v:
                parent[v] = u
                que.append(v)
    
    dp0 = [0] * n
    dp1 = [0] * n
    dp2 = [0] * n
    
    for u in reversed(que):
        v1, v2, v3 = 0, 0, 1
        s1, s2 = 0, 1
        
        for v in path[u]:
            if parent[v] == u:
                v1 = (v1 * dp2[v] + v2 * dp1[v]) % mod
                v2 = (v2 * dp2[v] + v3 * dp1[v]) % mod
                v3 = v3 * dp2[v] % mod
                
                s1 = (s1 * dp0[v] + s2 * dp1[v]) % mod
                s2 = s2 * dp0[v] % mod
        
        dp0[u] = v1
        dp1[u] = (v2 + s2) % mod
        dp2[u] = (dp0[u] + s1 + s2) % mod
    
    print(dp2[0])
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, mod = 1e9 + 7;
    cin >> n;

    vector<vector<int>> path(n);
    for (int i = 0; i < n - 1; i ++) {
        int u, v;
        cin >> u >> v;
        u --, v --;
        path[u].emplace_back(v);
        path[v].emplace_back(u);
    }

    vector<int> dp0(n, 0), dp1(n, 0), dp2(n, 0);

    auto dfs = [&] (auto &self, int u, int p) -> void {
        int v1 = 0, v2 = 0, v3 = 1, s1 = 0, s2 = 1;

        for (auto &v: path[u]) {
            if (v != p) {
                self(self, v, u);

                v1 = (1ll * v1 * dp2[v] + 1ll * v2 * dp1[v]) % mod;
                v2 = (1ll * v2 * dp2[v] + 1ll * v3 * dp1[v]) % mod;
                v3 = 1ll * v3 * dp2[v] % mod;

                s1 = (1ll * s1 * dp0[v] + 1ll * s2 * dp1[v]) % mod;
                s2 = 1ll * s2 * dp0[v] % mod;
            }
        }

        dp0[u] = v1, dp1[u] = (v2 + s2) % mod, dp2[u] = ((dp0[u] + s1) % mod + s2) % mod;
    };

    dfs(dfs, 0, -1);

    cout << dp2[0];

    return 0;
}
```
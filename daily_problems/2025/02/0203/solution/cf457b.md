**提示 1：** 找到合适的合并策略。

考虑 $a_i,b_j$ 如何相遇。

一种情况是直接合并，另一种情况是两者全部都复制到一个新的位置。

所有元素中一定有可以不被复制的，而这个数字一定可以变为 $a$ 或 $b$ 中的最大值。

不妨设是 $a$ 中最大值。

则 $b$ 中元素都得复制到 $a$ 中最大值的位置。

对于 $a$ 中剩余的元素，有两种选择：一种是直接移动到 $a$ 中最大值的位置，一种是把 $b$ 中所有元素都复制到当前元素。两者取其小即可。

时间复杂度为 $\mathcal{O}(n+m)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    nums1 = LII()
    nums2 = LII()

    nums1.sort()
    nums2.sort()

    v1 = sum(nums1)
    v2 = sum(nums2)

    ans = inf

    cur = 0
    for i in range(n):
        ans = fmin(ans, v2 * (n - i) + cur)
        cur += nums1[i]

    cur = 0
    for i in range(m):
        ans = fmin(ans, v1 * (m - i) + cur)
        cur += nums2[i]

    print(ans)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m;
    cin >> n >> m;

    vector<int> nums1(n), nums2(m);
    long long v1 = 0, v2 = 0;

    for (auto &x: nums1)
        cin >> x, v1 += x;
    
    for (auto &x: nums2) 
        cin >> x, v2 += x;
    
    sort(nums1.begin(), nums1.end());
    sort(nums2.begin(), nums2.end());

    __int128_t ans = 1e20;
    long long cur;

    cur = 0;
    for (int i = 0; i < n; i ++) {
        ans = min(ans, (__int128_t)1 * v2 * (n - i) + cur);
        cur += nums1[i];
    }

    cur = 0;
    for (int i = 0; i < m; i ++) {
        ans = min(ans, (__int128_t)1 * v1 * (m - i) + cur);
        cur += nums2[i];
    }

    cout << (long long) ans;

    return 0;
}
```
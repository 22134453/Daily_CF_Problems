**提示 1：** 根据题意模拟即可。每一轮有一个被做手术。

**提示 2：** 分别考虑被做手术的人劝退和被怕做手术的人劝退。

因为数据范围仅仅为 $4000$ ，所以考虑直接模拟。

假设我们现在处理第 $i$ 个人做手术，则我们先根据距离，考虑剩余还没走的人，用对应的声音去减少他们的信心值。

接下来，再考虑这些人走的情况。不妨认为他们是从左到右按照顺序走的，因为这样先走的人可以给后走的人带来进一步的信心损失，如果这种情况下都不走，最后一定不走。

假设走到 $j$ 下标时，因为前面的人走了带来的总损失是 $x$ ，则此时这个下标的信心值减去 $x$ 。如果小于 $0$ ，那么这个人也得走，同时给后面的人进一步带来了 $d[j]$ 的损失，因此更新 $x$ 为 $x+d[j]$ 。因此再遍历一遍就解决问题了。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    
    dp = [0] * n
    stk = []
    
    for i in range(n - 1, -1, -1):
        res = 0
        while stk and nums[stk[-1]] < nums[i]:
            res = fmax(res + 1, dp[stk.pop()])
        
        stk.append(i)
        dp[i] = res
    
    print(max(dp))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    vector<int> stk;
    vector<int> dp(n);

    for (int i = n - 1; i >= 0; i --) {
        int res = 0;

        while (!stk.empty() && nums[stk.back()] < nums[i]) {
            res = max(res + 1, dp[stk.back()]);
            stk.pop_back();
        }

        stk.emplace_back(i);
        dp[i] = res;
    }

    cout << *max_element(dp.begin(), dp.end());

    return 0;
}
```
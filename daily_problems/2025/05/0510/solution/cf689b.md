**提示 1：** 如果直接建图跑最短路有啥问题？

**提示 2：** 用一个方式表示 $i\to j$ 边权为 $|i-j|$ 的边。

本题本身就是求从 $1$ 开始到达每个位置的最短路。

于是考虑建图，从 $i$ 向 $p_i$ 建立一条边权为 $1$ 的边。

而如果我们对所有 $i$ 到 $j$ 建立一条 $|i-j|$ 的边，则边数会达到 $\mathcal{O}(n^2)$ ，是不合理的。

考虑绝对值几何含义，就是坐标轴上的距离，而 “距离” 本身就是最短路。考虑对 $1\to 2,2\to 1,\dots,n-1\to n,n\to n-1$ 建边权为 $1$ 的边。这样任意两个位置 $i$ 到 $j$ 相当于建了上述要求的边。

于是基于这些边跑最短路就行。因为边权都是 $1$ ，所以可以使用 BFS 。

注意这里无需真的建图，因为图中的边都很容易找到。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()

    ans = [[0] * n for _ in range(n)]

    for i in range(n - 1):
        for j in range(n - 1):
            ans[i][j] = (i + j) % (n - 1) + 1

    for i in range(n):
        ans[-1][i] = ans[i][i]
        ans[i][-1] = ans[i][i]
        ans[i][i] = 0

    print('\n'.join(' '.join(map(str, x)) for x in ans))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<vector<int>> grid(n, vector<int>(n, 0));

    for (int i = 0; i < n - 1; i ++) {
        for (int j = 0; j < n - 1; j ++) {
            grid[i][j] = (i + j) % (n - 1) + 1;
        }
    }

    for (int i = 0; i < n; i ++) {
        grid[n - 1][i] = grid[i][i];
        grid[i][n - 1] = grid[i][i];
        grid[i][i] = 0;
    }

    for (int i = 0; i < n; i ++) {
        for (int j = 0; j < n; j ++) {
            cout << grid[i][j] << ' ';
        }
        cout << '\n';
    }

    return 0;
}
```
**提示 1：** 典型的动态规划问题。考虑到第 $i$ 个位置的最小总成本。

**提示 2：** 三种转移——转移前是什么状态？

首先，题目设定让人联想到动态规划问题。因为本质上是挑选区间对点进行覆盖，这件事是很常见的线性 DP 。

接下来怎么办呢？考虑常见的状态定义：覆盖到第 $i$ 个位置的最小成本为 $dp[i]$ 。

这个 dp 根据前一次买的票有三种不同的转移方式——

- 单程： $dp[i-1]+20$ 。

- $90$ 分钟票：找到上一次跟这次时间间隔不到 $90$ 分钟的下标 $i_1$ ，则最后一张票最多覆盖这么多时间点，于是，前面的时间点只能单独考虑，因此前面部分成本为 $dp[i_1-1]$ ，新买的票是 $50$ 。

- $1440$ 分钟票：与前一种票类似，有 $dp[i_2-1]+120$ 。

三者取最小即可。 $i_1,i_2$ 单调变化，因此无需使用二分，指针移动即可。

时间复杂度为 $\mathcal{O}(nm^2)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, m = MII()
    grid = [[ord(c) - ord('a') for c in I()] for _ in range(n)]

    hsh = [1] * 26
    hsh[1] = random.randint(1000, 2000)
    mod = random.getrandbits(60)

    for i in range(2, 26):
        hsh[i] = hsh[i - 1] * hsh[1] % mod

    def f(cur):
        tmp = [-1]
        for v in cur:
            tmp.append(v)
            tmp.append(-1)
        
        res = 0
        k = len(tmp)
        wing = [0] * k
        
        chosen_idx = 0
        for i in range(k):
            if chosen_idx + wing[chosen_idx] >= i:
                wing[i] = fmin(chosen_idx + wing[chosen_idx] - i, wing[2 * chosen_idx - i])
            while i > wing[i] and i + 1 + wing[i] < k and tmp[i - wing[i] - 1] == tmp[i + wing[i] + 1]: wing[i] += 1
            res += (wing[i] + 1) // 2
            if i + wing[i] > chosen_idx + wing[chosen_idx]:
                chosen_idx = i

        return res

    ans = 0
    for j1 in range(m):
        msk = [0] * n
        tmp = [0] * n
        for j2 in range(j1, m):
            for i in range(n):
                msk[i] ^= 1 << grid[i][j2]
                tmp[i] += hsh[grid[i][j2]]
                if tmp[i] >= mod: tmp[i] -= mod
            
            cur = []
            for i in range(n):
                if msk[i] & -msk[i] == msk[i]:
                    cur.append(tmp[i])
                else:
                    ans += f(cur)
                    cur.clear()
            
            ans += f(cur)

    print(ans)
```

C++ 做法如下——

```cpp []
int main()
{
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> nums(n + 1, -2000);
    for (int i = 1; i <= n; i ++)
        cin >> nums[i];
    
    vector<int> dp(n + 1, 0);
    int p1 = 0, p2 = 0;

    for (int i = 1; i <= n; i ++) {
        dp[i] = dp[i - 1] + 20;
        while (nums[i] - nums[p1] >= 90) p1 ++;
        dp[i] = min(dp[i], dp[p1 - 1] + 50);
        while (nums[i] - nums[p2] >= 1440) p2 ++;
        dp[i] = min(dp[i], dp[p2 - 1] + 120);
    }

    for (int i = 0; i < n; i ++)
        cout << dp[i + 1] - dp[i] << '\n';

    return 0;
}
```

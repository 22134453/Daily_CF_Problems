**提示 1：** 对于一个长方体，答案是多少？

**提示 2：** 两种情况——一个石头、两个石头。后者只需对于一个面找最长的一条边就行。

对于一个长方体，其最大能雕出多大的球呢？是其最短边长度除以 $2$ 。

因此我们只需找到最短边最大的长方体即可。

如果是单个长方体形成的答案，直接取该长方体对应的最短边就行。

否则，两个长方体需要发生拼接，考虑拼接面必须一致。考虑第 $i$ 个石头和前面 $i-1$ 个石头能拼出来的最大的长方体。

我们只需枚举拼接的那个面，找到前 $i-1$ 个石头中，有对应面的剩下一条边尽可能长（这一步是贪心，会使得最小值尽可能大）的长方体。因此，只需维护每个面对应的最大高，及对应的石头即可。

在遍历的过程中不断枚举拼接面，并将当前长方体加入维护即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    note = [[0] * n for _ in range(3)]

    x, y = -1, -1
    for i in range(3):
        s = I()
        for j in range(n):
            if s[j] == 'X': note[i][j] = 1
            elif s[j] == 'O':
                note[i][j] = 2
                x, y = i, j

    dirs = [(-1, 0), (0, 1), (1, 0), (0, -1)]
    chosen = []

    for dx, dy in dirs:
        flg = True
        for i in range(1, 3):
            vx, vy = x + dx * i, y + dy * i
            if not (0 <= vx < 3 and 0 <= vy < n and note[vx][vy] == 0):
                flg = False
        if flg:
            chosen.append((dx, dy))

    k = len(chosen)
    ans = 0
    mod = 10 ** 9 + 7

    for msk in range(1, 1 << k):
        c = -1
        for i in range(k):
            if msk >> i & 1:
                c = -c
                dx, dy = chosen[i]
                for j in range(1, 3):
                    note[x + dx * j][y + dy * j] = 1

        dp = [0] * 8
        dp[0] = 1
        
        ndp = [0] * 8
        
        for i in range(n):
            must = 0
            for j in range(3):
                if note[j][i]:
                    must |= 1 << j
            
            for v0 in range(8):
                for v1 in range(8):
                    if v1 & must == 0 and v0 & v1 == 0 and v0 & must == 0 and (7 - v1 - must - v0) % 3 == 0:
                        ndp[v1] += dp[v0]
                        if ndp[v1] >= mod:
                            ndp[v1] -= mod

            for j in range(8):
                dp[j] = ndp[j]
                ndp[j] = 0
        
        ans += c * dp[0]
        
        for i in range(k):
            if msk >> i & 1:
                dx, dy = chosen[i]
                for j in range(1, 3):
                    note[x + dx * j][y + dy * j] = 0

    print(ans % mod)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<vector<int>> note(3, vector<int>(n, 0));
    int x, y;

    for (int i = 0; i < 3; i ++) {
        string s;
        cin >> s;
        for (int j = 0; j < n; j ++) {
            if (s[j] == 'X') note[i][j] = 1;
            else if (s[j] == 'O') {
                note[i][j] = 2;
                x = i, y = j;
            }
        }
    }

    vector<int> dirs = {-1, 0, 1, 0, -1};
    vector<pair<int, int>> chosen;

    for (int i = 0; i < 4; i ++) {
        int dx = dirs[i], dy = dirs[i + 1];
        bool flg = true;

        for (int j = 1; j < 3; j ++) {
            int vx = x  + dx * j, vy = y + dy * j;
            if (!(vx >= 0 && vx < 3 && vy >= 0 && vy < n && note[vx][vy] == 0)) {
                flg = false;
            }
        }

        if (flg) chosen.emplace_back(dx, dy);
    }

    int k = chosen.size(), ans = 0, mod = 1e9 + 7;

    for (int msk = 1; msk < (1 << k); msk ++) {
        int c = -1;
        for (int i = 0; i < k; i ++) {
            if (msk >> i & 1) {
                c = -c;
                auto &[dx, dy] = chosen[i];
                for (int j = 1; j < 3; j ++) {
                    note[x + dx * j][y + dy * j] = 1;
                }
            }
        }

        vector<int> dp(8, 0), ndp(8, 0);
        dp[0] = 1;

        for (int i = 0; i < n; i ++) {
            int must = 0;
            for (int j = 0; j < 3; j ++) {
                if (note[j][i]) {
                    must |= 1 << j;
                }
            }

            for (int v0 = 0; v0 < 8; v0 ++) {
                for (int v1 = 0; v1 < 8; v1 ++) {
                    if ((v1 & must) == 0 && (v0 & v1) == 0 && (v0 & must) == 0 && (7 - v1 - must - v0) % 3 == 0) {
                        ndp[v1] += dp[v0];
                        if (ndp[v1] >= mod) ndp[v1] -= mod;
                    }
                }
            }

            for (int j = 0; j < 8; j ++)
                dp[j] = ndp[j], ndp[j] = 0;
        }

        ans += c * dp[0];
        if (ans >= mod) ans -= mod;
        if (ans < 0) ans += mod;

        for (int i = 0; i < k; i ++) {
            if (msk >> i & 1) {
                auto &[dx, dy] = chosen[i];
                for (int j = 1; j < 3; j ++) {
                    note[x + dx * j][y + dy * j] = 0;
                }
            }
        }
    }

    cout << ans;

    return 0;
}
```

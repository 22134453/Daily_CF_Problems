**提示 1：** $2,3,5$ 的倍数需要满足什么条件？

**提示 2：** 删去的元素应该越少越好——数量一定时，删去的元素越小越好。

$2,3,5$ 的倍数要满足什么条件呢？

如果一个数既是 $2$ 的倍数又是 $5$ 的倍数，那么它一定是 $10$ 的倍数，于是结尾数字一定是 $0$ 。

因此，如果 $0$ 不在输入中，一定无法构造；同时，如果 $0$ 在输入中，一定至少可以构造出 $0$ 。

因为 $x\times 10^i\bmod 3=x\times(99...9+1)\bmod 3=x\bmod 3$ ，于是一个数除以 $3$ 的余数可以视为其数码和除以 $3$ 的余数。

最后结果位数越大越好，所以要删去尽可能少的元素。

如果不删 / 删去一个元素就能满足要求，直接数据答案即可。

否则假设当前 $\bmod 3$ 结果为 $i$ ，则给的输入数中，只包含能被 $3$ 整除或 $\bmod 3$ 结果为 $3-i$ 的数码。此时，只需选择两个最小的 $\bmod 3$ 结果为 $3-i$ 的数码即可。

选完数码后，逆序输出即可。注意，输出为 $0$ 时不要带前导 $0$ 。

时间复杂度为 $\mathcal{O}(\log M\epsilon^{-1})$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    x1, y1, x2, y2 = MII()
    vm, t = MII()
    vx, vy = MII()
    wx, wy = MII()

    x2 -= x1
    y2 -= y1

    l, r = 0, 10 ** 9
    for _ in range(120):
        m = (l + r) / 2
        x, y = x2, y2
        x -= vx * fmin(m, t)
        y -= vy * fmin(m, t)
        x -= wx * (m - fmin(m, t))
        y -= wy * (m - fmin(m, t))
        
        if x * x + y * y <= vm * vm * m * m: r = m
        else: l = m

    print((l + r) / 2)
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int x1, y1, x2, y2, vm, vx, vy, wx, wy;
    long double t;
    cin >> x1 >> y1 >> x2 >> y2 >> vm >> t >> vx >> vy >> wx >> wy;

    x2 -= x1, y2 -= y1;
    long double l = 0, r = 1e9;

    for (int i = 0; i < 120; i ++) {
        long double m = (l + r) / 2;
        long double x = x2, y = y2;
        x -= min(m, t) * vx;
        y -= min(m, t) * vy;
        x -= (m - min(m, t)) * wx;
        y -= (m - min(m, t)) * wy;
        
        if (x * x + y * y <= vm * vm * m * m) r = m;
        else l = m;
    }

    cout << fixed << setprecision(20) << (l + r) / 2;

    return 0;
}
```

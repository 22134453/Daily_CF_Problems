**提示 1：** 首先找到长宽分别不超过 $n,m$ 的最大的满足条件形状的矩形。

**提示 2：** 左端点和下端点分别需要满足什么条件？

首先先考虑提示 1，可以发现将形状 $(a,b)$ 分别除以最大公约数后，剩余了 $(a',b')$ ，只需考虑 $ka'\leq n, kb'\leq m$ 的最大的 $k$ 即可。

设这个矩形的长和宽分别是 $v,w$ ，接下来就是考虑把这个矩形平移。

在这个矩形足够大时，最优的选择是 $x-\lceil\frac{v}{2}\rceil, y-\lceil\frac{w}{2}\rceil$ 。

但同时我们的矩形要在给定的矩形内部，所以还需要调整到 $[0,n-v],[0,m-w]$ 内，即得结果。

时间复杂度为 $\mathcal{O}(\log M)$。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()

    q = II()
    ts = []
    xs = []
    ys = []
    zs = []

    for _ in range(q):
        query = LII()
        if query[0] == 1:
            ts.append(0)
            xs.append(query[1] - 1)
            ys.append(query[2])
            zs.append(0)
        else:
            ts.append(1)
            xs.append(query[1] - 1)
            ys.append(query[2] - 1)
            zs.append(query[3])

    fen = FenwickTree(n)
    tmp = [0] * n

    ans = [-1] * q

    for i in range(2, 7):
        weight = [0] * (2 * i - 2)
        for j in range(i - 1):
            weight[j] = j + 1
        for j in range(i - 1, 2 * i - 2):
            weight[j] = 2 * i - j - 1
        l = 2 * i - 2
        
        for start in range(l):
            for j in range(n):
                tmp[j] = nums[j] * weight[(j - start) % l]
            fen.init(tmp)
            
            for j in range(q):
                if ts[j] == 0:
                    fen.add(xs[j], ys[j] * weight[(xs[j] - start) % l] - tmp[xs[j]])
                    tmp[xs[j]] = ys[j] * weight[(xs[j] - start) % l]
                elif xs[j] % l == start and zs[j] == i:
                    ans[j] = fen.rsum(xs[j], ys[j])

    print('\n'.join(str(x) for x in ans if x != -1))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, x, y, a, b;
    cin >> n >> m >> x >> y >> a >> b;

    int g = gcd(a, b);
    a /= g;
    b /= g;

    int t = min(n / a, m / b);
    int v = t * a, w = t * b;

    int x0 = min(n - v, max(x - (v + 1) / 2, 0));
    int y0 = min(m - w, max(y - (w + 1) / 2, 0));

    cout << x0 << ' ' << y0 << ' ' << x0 + v << ' ' << y0 + w;

    return 0;
}
```
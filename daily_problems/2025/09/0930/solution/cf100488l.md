**提示 1：** 先从小情况入手。可以怎么做？

首先， $n=2k+1$ 比 $n=2k$ 只多了一个元素，但却能多查询一次，因此不妨让这次查询查 $n$ 这个位置，这样我们接下来就只需考虑偶数的情况。

如果你读到这里了，不妨试试看 $6$ 咋查。

方案是，先查 $[1,3]$ ，这样就知道哪些元素在前一半，哪些元素在后一半；接下来，对称地查询 $[1,5],[2,4]$ ，这样和 $[1,6]$ 的结果进行对比可以得到 $1,6$ ， $2,5$ 与 $3,4$ 有哪些元素，进一步根据哪些元素在前面，哪些元素在后面，可以确定每一个位置对应的元素。

于是对于其他偶数 $n$ 也是类似的，直接查询 $[1,n/2]$ ，确认前后两半部分分别是什么元素，接下来查询 $[2,n-1],[3,n-2],\dots,[n/2,n/2+1]$ 即可。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n, l, r = MII()
    s = I()
    
    stk_left = list(s[:l-1])
    que_mid = deque(s[l-1:r])
    stk_right = list(s[r:])
    stk_right.reverse()
    
    q = II()
    flg = 1
    outs = []
    
    for _ in range(q):
        query = LI()
        
        if query[0] == 'Q':
            outs.append(que_mid[0] if (query[1] == 'L') == flg else que_mid[-1])
        elif query[0] == 'R':
            flg ^= 1
        else:
            if query[1] == 'L':
                if query[2] == 'L':
                    if flg:
                        que_mid.appendleft(stk_left.pop())
                    else:
                        que_mid.append(stk_left.pop())
                else:
                    if flg:
                        stk_left.append(que_mid.popleft())
                    else:
                        stk_left.append(que_mid.pop())
            else:
                if query[2] == 'L':
                    if flg:
                        stk_right.append(que_mid.pop())
                    else:
                        stk_right.append(que_mid.popleft())
                else:
                    if flg:
                        que_mid.append(stk_right.pop())
                    else:
                        que_mid.appendleft(stk_right.pop())
    
    print(''.join(outs))
```

C++ 做法如下——

```cpp []
set<int> query(int l, int r) {
    cout << "Q " << l << ' ' << r << endl;
    set<int> st;
    for (int i = l; i <= r; i ++) {
        int x;
        cin >> x;
        st.insert(x);
    }
    return st;
}

void answer(vector<int> &ans) {
    cout << 'A';
    for (auto &x: ans) cout << ' ' << x;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;

    vector<int> ans(n);

    set<int> to_fill;
    for (int i = 1; i <= n; i ++)
        to_fill.insert(i);
    
    if (n & 1) {
        auto res = query(n, n);
        ans[n - 1] = *res.begin();
        to_fill.erase(ans[n - 1]), n --;
    }

    if (n > 1) {
        auto left = query(1, n / 2);
        set<int> right;

        for (auto &v: to_fill)
            if (left.find(v) == left.end())
                right.insert(v);
        
        for (int i = 2; i <= n / 2; i ++) {
            auto mid = query(i, n + 1 - i);
            
            for (auto v: left) {
                if (mid.find(v) == mid.end()) {
                    left.erase(v);
                    ans[i - 2] = v;
                    break;
                }
            }

            for (auto v: right) {
                if (mid.find(v) == mid.end()) {
                    right.erase(v);
                    ans[n - i + 1] = v;
                    break;
                }
            }
        }

        ans[n / 2 - 1] = *left.begin();
        ans[n / 2] = *right.begin();
    }

    answer(ans);

    return 0;
}
```

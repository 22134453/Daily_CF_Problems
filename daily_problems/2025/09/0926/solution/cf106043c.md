**提示 1：** 考虑每个最大值对应的数组长度。

先看提示 1，这件事可以通过单调栈找到前后严格更大 / 更小的位置得到

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    nums = LII()
    dsu = UnionFind(n)
    vis = [0] * n
    
    max_length = [0] * (n + 1)
    
    for i in sorted(range(n), key=lambda x: nums[x]):
        if i and vis[i - 1]: dsu.merge(i, i - 1)
        if i + 1 < n and vis[i + 1]: dsu.merge(i, i + 1)
        
        vis[i] = 1
        if nums[i] < n:
            max_length[nums[i]] = fmax(max_length[nums[i]], dsu.getSize(i))
    
    for i in range(1, n + 1):
        max_length[i] = fmin(max_length[i], max_length[i - 1])
    
    ans = [0] * (n + 1)
    
    for i in range(n + 1):
        ans[max_length[i]] = i + 1
    
    for i in range(n - 1, -1, -1):
        ans[i] = fmax(ans[i], ans[i + 1])
    
    print(' '.join(map(str, ans[1:])))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n;
    cin >> n;
    vector<int> nums(n);
    for (auto &v: nums) cin >> v;

    vector<int> idxs(n), vis(n, 0), max_length(n + 1, 0);
    atcoder::dsu uf(n);

    iota(idxs.begin(), idxs.end(), 0);
    sort(idxs.begin(), idxs.end(), [&] (int i, int j) {return nums[i] < nums[j];});

    for (auto &idx: idxs) {
        if (idx && vis[idx - 1]) uf.merge(idx - 1, idx);
        if (idx + 1 < n && vis[idx + 1]) uf.merge(idx + 1, idx);

        vis[idx] = 1;
        if (nums[idx] < n)
            max_length[nums[idx]] = max(max_length[nums[idx]], uf.size(idx));
    }

    for (int i = 1; i <= n; i ++)
        max_length[i] = min(max_length[i], max_length[i - 1]);
    
    vector<int> ans(n + 1, 0);

    for(int i = 0; i <= n; i ++)
        ans[max_length[i]] = i + 1;
    
    for (int i = n - 1; i >= 0; i --)
        ans[i] = max(ans[i], ans[i + 1]);
    
    for (int i = 1; i <= n; i ++)
        cout << ans[i] << ' ';

    return 0;
}
```

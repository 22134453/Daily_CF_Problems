**提示 1：** 要求刚好填满的方案数量，这是典型的背包 DP 。

**提示 2：** 我们要进行状态转移还需要记录什么状态？

这题要求长度为 $l$ 的序列数量，这件事非常符合背包 DP 的要求，考虑背包 DP 。

背包 DP 的其中一个状态是当前使用的总长度。但我们题目还有别的要求需要满足：

- 不能跟前一个块是同一个类型。

- 当前的块的长度得和前一块的宽度相同。

这两件事可以同时定义共计 $\mathcal{O}(n)$ 种的状态解决：当前的结束块的类型和摆放的方向。这个状态就足以检查上述的两个条件。

这样，总共有 $\mathcal{O}(nl)$ 种不同的状态，而每个状态只需枚举下一次使用的块及摆放方向，即可检查是否合法并进行状态转移。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    t = II()
    outs = []

    for _ in range(t):
        b, n = MII()
        cur = 1
        for i in range(1, n + 1):
            cur = cur * b % n
            if cur == 0:
                outs.append(f'1 {i}')
                break
            if cur == 1:
                outs.append(f'2 {i}')
                break
            if cur == n - 1:
                outs.append(f'3 {i}')
                break
        else:
            outs.append('0')

    print('\n'.join(outs))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int t;
    cin >> t;

    while (t --) {
        int b, n;
        cin >> b >> n;
        int cur = 1;
        bool flg = true;

        for (int i = 1; i <= n; i ++) {
            cur = 1ll * cur * b % n;
            if (cur == 0) {
                cout << "1 " << i << '\n';
                flg = false;
                break;
            }
            if (cur == 1) {
                cout << "2 " << i << '\n';
                flg = false;
                break;
            }
            if (cur == n - 1) {
                cout << "3 " << i << '\n';
                flg = false;
                break;
            }
        }

        if (flg) cout << "0\n";
    }

    return 0;
}
```
**提示 1：** 单独考虑每个城市。

**提示 2：** 分别考虑到达和离开。

考虑每个城市的人在 $t$ 时刻到达 $0$ 城的最小成本。

则我们可以找到所有到达 $0$ 城的路线，将其按照时间排序，则其成本为前缀成本最小值。

同样的，在 $t$ 时刻离开 $0$ 城的最小成本相当于是一个后缀成本最小值。

考虑分别统计到达和离开的成本，即 $t$ 时刻前到达的成本和 $t$ 时刻离开的成本。这个成本是对不同城市进行加总的。

对于每个城市而言，上面用于加总每个最小值对应的是一段时间区间，因此我们要进行的是区间加的操作，可以通过差分后前缀和来实现。

最后，我们需要使得离开的时间至少是到达的时间加上 $k+1$ ，我们枚举所有的到达时间即可。

时间复杂度为 $\mathcal{O}(n)$ 。

### 具体代码如下——

Python 做法如下——

```Python []
def main():
    n = II()
    cols = [II() for _ in range(n)]
    path = [[] for _ in range(n)]

    for _ in range(n - 1):
        u, v = GMI()
        path[u].append(v)
        path[v].append(u)

    ops = [0]
    parent = [-1] * n

    def operate(u):
        cols[u] = -cols[u]
        ops.append(u)

    stk = [0]
    while stk:
        u = stk.pop()
        if u >= 0:
            if u > 0: operate(u)
            stk.append(~u)
            
            for v in path[u]:
                if parent[u] != v:
                    parent[v] = u
                    stk.append(v)
        else:
            u = ~u
            if u > 0:
                operate(parent[u])
            if cols[u] != 1:
                if u > 0:
                    operate(u)
                    operate(parent[u])
                else:
                    v = path[u][0]
                    operate(v)
                    operate(u)
                    operate(v)

    print(' '.join(str(x + 1) for x in ops))
```

C++ 做法如下——

```cpp []
int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(0);
    cout.tie(0);

    int n, m, k;
    cin >> n >> m >> k;

    vector<vector<pair<int, int>>> froms(n + 1), tos(n + 1);

    while (m --) {
        int d, f, t, c;
        cin >> d >> f >> t >> c;
        if (f) froms[f].emplace_back(d, c);
        else tos[t].emplace_back(d, c);
    }

    long long inf = 1e13;
    int M = 1e6;

    vector<long long> ans1(M + 2, 0), ans2(M + 2, 0);

    for (int i = 1; i <= n; i ++) {
        sort(froms[i].begin(), froms[i].end());
        sort(tos[i].begin(), tos[i].end());

        int fk = froms[i].size(), tk = tos[i].size();

        if (fk == 0 || tk == 0) return cout << -1, 0;

        long long v;

        ans1[0] += inf;
        ans1[froms[i][0].first] -= inf;

        v = inf;
        for (int j = 0; j < fk - 1; j ++) {
            v = min(v, (long long)froms[i][j].second);
            ans1[froms[i][j].first] += v;
            ans1[froms[i][j + 1].first] -= v;
        }

        v = min(v, (long long)froms[i][fk - 1].second);
        ans1[froms[i][fk - 1].first] += v;
        ans1[M + 1] -= v;

        ans2[tos[i][tk - 1].first + 1] += inf;
        ans2[M + 1] -= inf;

        v = inf;
        for (int j = tk - 2; j >= 0; j --) {
            v = min(v, (long long)tos[i][j + 1].second);
            ans2[tos[i][j].first + 1] += v;
            ans2[tos[i][j + 1].first + 1] -= v;
        }

        v = min(v, (long long)tos[i][0].second);
        ans2[0] += v;
        ans2[tos[i][0].first + 1] -= v;
    }

    for (int i = 0; i <= M; i ++) {
        ans1[i + 1] += ans1[i];
        ans2[i + 1] += ans2[i];
    }

    long long ans = inf;
    for (int i = 0; i <= M + 1; i ++) {
        if (i + k + 1 <= M) {
            ans = min(ans, ans1[i] + ans2[i + k + 1]);
        }
    }

    cout << (ans < inf ? ans : -1);

    return 0;
}
```